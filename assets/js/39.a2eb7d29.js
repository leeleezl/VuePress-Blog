(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{449:function(v,_,s){"use strict";s.r(_);var t=s(2),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"redis-作为缓存要知道的那些事儿"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-作为缓存要知道的那些事儿"}},[v._v("#")]),v._v(" Redis 作为缓存要知道的那些事儿")]),v._v(" "),_("h2",{attrs:{id:"redis-作为缓存是如何工作的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-作为缓存是如何工作的"}},[v._v("#")]),v._v(" Redis 作为缓存是如何工作的")]),v._v(" "),_("h3",{attrs:{id:"缓存的特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存的特征"}},[v._v("#")]),v._v(" 缓存的特征")]),v._v(" "),_("ol",[_("li",[v._v("在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。对应到互联网应用来说，Redis 就是快速子系统，而数据库就是慢速子系统了。")]),v._v(" "),_("li",[v._v("缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。")])]),v._v(" "),_("h3",{attrs:{id:"redis-缓存处理请求的两种情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-缓存处理请求的两种情况"}},[v._v("#")]),v._v(" Redis 缓存处理请求的两种情况")]),v._v(" "),_("p",[v._v("**缓存命中：**Redis 中有相应的数据，就直接读取 Redis，性能非常快。")]),v._v(" "),_("p",[v._v("**缓存缺失：**Redis 中没有保存相应的数据，就从后端数据库中读取相应的数据，性能就会变慢。")]),v._v(" "),_("h3",{attrs:{id:"redis-作为旁路缓存的使用操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-作为旁路缓存的使用操作"}},[v._v("#")]),v._v(" Redis 作为旁路缓存的使用操作")]),v._v(" "),_("p",[v._v("我们把 Redis 称为旁路缓存是因为读取缓存、读取数据库和更新缓存的操作都需要在应用程序中完成。")]),v._v(" "),_("p",[v._v("使用 Redis 缓存时，我们需要在应用程序中增加 3 方面的代码：")]),v._v(" "),_("blockquote",[_("ul",[_("li",[v._v("当应用程序需要读取数据时，我们需要在代码中显式调用 Redis 的 GET 操作接口，进行查询；")]),v._v(" "),_("li",[v._v("如果缓存缺失了，应用程序需要再和数据库连接，从数据库中读取数据；")]),v._v(" "),_("li",[v._v("当缓存中的数据需要更新时，我们也需要在应用程序中显式地调用 SET 操作接口，把更新的数据写入缓存。")])])]),v._v(" "),_("p",[v._v("在使用旁路缓存时，我们需要应用程序中增加操作代码，增加了使用 Redis 缓存的额外工作量，但是，也正因为 Redis 是旁路缓存，是一个独立的系统，我们可以单独对 Redis 缓存进行扩容和性能优化。")]),v._v(" "),_("h3",{attrs:{id:"缓存的类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存的类型"}},[v._v("#")]),v._v(" 缓存的类型")]),v._v(" "),_("ul",[_("li",[v._v("只读缓存：先读 Redis 缓存，命中则直接返回，未命中读取后端数据库，并同时将数据存入缓存；写请求直接发给后端数据库，在数据库中增删改，对于删改的数据来说，如果 Redis 已经缓存了，则将其删除。")]),v._v(" "),_("li",[v._v("读写缓存：所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。此时，得益于Redis 的高性能访问特性，数据的增删改操作可以在缓存中快速完成，处理结果也会快速返回给业务应用，这就可以提升业务应用的响应速度。根据业务应用对数据可靠性和缓存性能的不同要求，我们会有"),_("strong",[v._v("同步直写和异步写回")]),v._v("两种策略。其中，"),_("strong",[v._v("同步直写策略优先保证数据可靠性，而异步写回策略优先提供快速响应")]),v._v("。")])]),v._v(" "),_("h2",{attrs:{id:"缓存满了怎么办"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存满了怎么办"}},[v._v("#")]),v._v(" 缓存满了怎么办")]),v._v(" "),_("h3",{attrs:{id:"redis-缓存的淘汰策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-缓存的淘汰策略"}},[v._v("#")]),v._v(" Redis 缓存的淘汰策略")]),v._v(" "),_("p",[v._v("Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略。")]),v._v(" "),_("blockquote",[_("p",[v._v("noeviction：不进行数据淘汰的策略（Redis 的默认设置）")]),v._v(" "),_("p",[v._v("在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis 4.0 后新增）四种。")]),v._v(" "),_("p",[v._v("在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis4.0 后新增）三种。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"img/Snipaste_2022-03-23_18-28-14.png",alt:""}})]),v._v(" "),_("p",[v._v("设置过期时间：")]),v._v(" "),_("ul",[_("li",[v._v("volatile-ttl：会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除")]),v._v(" "),_("li",[v._v("volatile-random：针对设置了过期时间的键值对，随机选择删除")]),v._v(" "),_("li",[v._v("volatile-lru：针对设置了过期时间的键值对，根据 LRU（最近最少使用）算法进行淘汰")]),v._v(" "),_("li",[v._v("volatile-lfu：针对设置了过期时间的键值对，根据 LFR（最不经常使用）算法进行淘汰")])]),v._v(" "),_("p",[v._v("未设置过期时间：")]),v._v(" "),_("ul",[_("li",[v._v("allkeys-random：从所有键值对中随机选择并删除")]),v._v(" "),_("li",[v._v("allkeys-lru：从所有键值对中根据 LRU（最近最少使用）算法进行淘汰")]),v._v(" "),_("li",[v._v("allkeys-lfu：从所有的键值对中根据 LFR（最不经常使用）算法进行淘汰")])]),v._v(" "),_("h3",{attrs:{id:"如何处理被淘汰的数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何处理被淘汰的数据"}},[v._v("#")]),v._v(" 如何处理被淘汰的数据？")]),v._v(" "),_("p",[_("strong",[v._v("一般情况下")]),v._v("，一旦淘汰的数据选定后，如果这个数据是干净数据，那么直接删除；如果是脏数据则需要写回数据库。而"),_("strong",[v._v("对于 Redis 来说")]),v._v("，它决定了被淘汰的数据后，会把它们删除。即使淘汰的数据是脏数据，Redis 也不会把它们写回数据库。所以，我们在使用 Redis 缓存时，如果数据被修改了，需要在数据修改时就将它写回数据库。否则，这个脏数据被淘汰时，会被 Redis 删除，而数据库里也没有最新的数据了")]),v._v(" "),_("h2",{attrs:{id:"如何解决缓存和数据库数据不一致问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决缓存和数据库数据不一致问题"}},[v._v("#")]),v._v(" 如何解决缓存和数据库数据不一致问题？")]),v._v(" "),_("h3",{attrs:{id:"缓存和数据库的数据不一致是如何发生的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存和数据库的数据不一致是如何发生的"}},[v._v("#")]),v._v(" 缓存和数据库的数据不一致是如何发生的？")]),v._v(" "),_("p",[_("img",{attrs:{src:"img/Snipaste_2022-03-23_18-56-20.png",alt:""}})]),v._v(" "),_("h3",{attrs:{id:"如何解决数据库不一致问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决数据库不一致问题"}},[v._v("#")]),v._v(" 如何解决数据库不一致问题？")]),v._v(" "),_("h4",{attrs:{id:"先删缓存后更新数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#先删缓存后更新数据库"}},[v._v("#")]),v._v(" 先删缓存后更新数据库")]),v._v(" "),_("p",[v._v("该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）")]),v._v(" "),_("ol",[_("li",[v._v("请求A进行写操作，删除缓存")]),v._v(" "),_("li",[v._v("请求B查询发现缓存不存在")]),v._v(" "),_("li",[v._v("请求B去数据库查询得到旧值")]),v._v(" "),_("li",[v._v("请求B将旧值写入缓存")]),v._v(" "),_("li",[v._v("请求A将新值写入数据库")])]),v._v(" "),_("p",[v._v("上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。")]),v._v(" "),_("p",[_("img",{attrs:{src:"img/Snipaste_2022-03-23_19-13-07.png",alt:""}})]),v._v(" "),_("p",[_("strong",[v._v("答案一：延时双删")])]),v._v(" "),_("p",[_("strong",[v._v("在线程 A 更新完数据库以后，可以让它 sleep 一段时间，再进行一次缓存删除。")])]),v._v(" "),_("blockquote",[_("p",[v._v("这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。自行评估自己的项目的读数据业务逻辑的耗时，写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。")])]),v._v(" "),_("p",[_("strong",[v._v("答案二：更新与读取操作进行异步串行化")])]),v._v(" "),_("p",[_("strong",[v._v("异步串行化")])]),v._v(" "),_("p",[v._v("在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。")]),v._v(" "),_("p",[v._v("这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。")]),v._v(" "),_("p",[_("strong",[v._v("读操作去重")])]),v._v(" "),_("p",[v._v("多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。")]),v._v(" "),_("p",[v._v("如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）")]),v._v(" "),_("h4",{attrs:{id:"先更新数据库在删除缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库在删除缓存"}},[v._v("#")]),v._v(" 先更新数据库在删除缓存")]),v._v(" "),_("p",[v._v("这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。")]),v._v(" "),_("p",[_("img",{attrs:{src:"http://blog-img.coolsen.cn/img/1735bb5881fb4a1b~tplv-t2oaga2asx-watermark.awebp",alt:"先更新数据库，后删除缓存"}})]),v._v(" "),_("p",[v._v("此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：")]),v._v(" "),_("ol",[_("li",[v._v("请求 A 先对数据库进行更新操作")]),v._v(" "),_("li",[v._v("在对 Redis 进行删除操作的时候发现报错，删除失败")]),v._v(" "),_("li",[v._v("此时将Redis 的 key 作为消息体发送到消息队列中")]),v._v(" "),_("li",[v._v("系统接收到消息队列发送的消息后再次对 Redis 进行删除操作")])]),v._v(" "),_("p",[v._v("但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。")]),v._v(" "),_("h4",{attrs:{id:"关于解决数据库不一致问题的总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关于解决数据库不一致问题的总结"}},[v._v("#")]),v._v(" 关于解决数据库不一致问题的总结")]),v._v(" "),_("p",[v._v("删除缓存值或更新数据库失败而导致数据不一致，你可以使用消息队列机制确保删除或更新操作成功。")]),v._v(" "),_("p",[v._v("在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作，导致其他线程读取到旧值，应对方案是延迟双删或者更新与读取操作进行异步串行化。")]),v._v(" "),_("h2",{attrs:{id:"如何解决缓存雪崩、击穿、穿透难题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决缓存雪崩、击穿、穿透难题"}},[v._v("#")]),v._v(" 如何解决缓存雪崩、击穿、穿透难题？")]),v._v(" "),_("h3",{attrs:{id:"缓存雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[v._v("#")]),v._v(" 缓存雪崩")]),v._v(" "),_("p",[v._v("缓存雪崩是指"),_("strong",[v._v("大量的应用请求无法在 Redis 缓存中处理，造成大量请求发送到数据库，导致数据库压力激增")]),v._v("。")]),v._v(" "),_("p",[v._v("造成缓存雪崩一般又两个原因导致：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("缓存中有大量的 key 同时过期，导致大量请求无法处理")])]),v._v(" "),_("li",[_("p",[v._v("Redis 缓存实例发生故障宕机无法处理请求")])])]),v._v(" "),_("p",[v._v("解决方案：")]),v._v(" "),_("p",[v._v("1、事前：")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("均匀过期")]),v._v("：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。如把每个Key的失效时间都加个随机值，"),_("code",[v._v("setRedis（Key，value，time + Math.random() * 10000）；")]),v._v("，保证数据不会在同一时间大面积失效。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("分级缓存")]),v._v("：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("热点数据缓存永远不过期")]),v._v("。永不过期实际包含两层意思：")]),v._v(" "),_("ul",[_("li",[v._v("物理不过期，针对热点key不设置过期时间")]),v._v(" "),_("li",[v._v("逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("保证Redis缓存的高可用")]),v._v("，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。")])])]),v._v(" "),_("p",[v._v("2、事中：")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("互斥锁")]),v._v("：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("使用熔断机制，限流降级")]),v._v("。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。")])])]),v._v(" "),_("p",[v._v("3、事后：")]),v._v(" "),_("p",[_("strong",[v._v("开启Redis持久化机制，尽快恢复缓存数据")]),v._v("，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。")]),v._v(" "),_("h3",{attrs:{id:"缓存击穿"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[v._v("#")]),v._v(" 缓存击穿")]),v._v(" "),_("p",[v._v("缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。")]),v._v(" "),_("p",[v._v("从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。")]),v._v(" "),_("p",[v._v("解决方案：")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量")]),v._v("，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("热点数据缓存永远不过期")]),v._v("。永不过期实际包含两层意思：")]),v._v(" "),_("ul",[_("li",[v._v("物理不过期，针对热点key不设置过期时间")]),v._v(" "),_("li",[v._v("逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建")])])])]),v._v(" "),_("h3",{attrs:{id:"缓存穿透"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[v._v("#")]),v._v(" 缓存穿透")]),v._v(" "),_("p",[v._v("缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。")]),v._v(" "),_("p",[v._v("解决方法：")]),v._v(" "),_("ul",[_("li",[v._v("将无效的key存放进Redis中：")])]),v._v(" "),_("p",[v._v('当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value="null"，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。')]),v._v(" "),_("ul",[_("li",[v._v("使用布隆过滤器：")])]),v._v(" "),_("p",[v._v("如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们"),_("strong",[v._v("可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在")]),v._v("，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。")]),v._v(" "),_("blockquote",[_("p",[v._v("如何选择：针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);